<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Oklab Color Space Explorer</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            overflow: hidden;
            background: #000;
        }
        #canvas-container {
            width: 100vw;
            height: 100vh;
        }
        #search-container {
            position: absolute;
            top: 20px;
            left: 50%;
            transform: translateX(-50%);
            z-index: 100;
            display: flex;
            gap: 12px;
            align-items: center;
        }
        #color-space-selector {
            padding: 12px 20px;
            font-size: 16px;
            border: 2px solid #444;
            border-radius: 25px;
            background: rgba(20, 20, 20, 0.9);
            color: #fff;
            outline: none;
            cursor: pointer;
            transition: all 0.3s;
        }
        #color-space-selector:hover {
            border-color: #888;
            background: rgba(30, 30, 30, 0.95);
        }
        #color-space-selector:focus {
            border-color: #888;
            background: rgba(30, 30, 30, 0.95);
        }
        #search-input {
            padding: 12px 20px;
            font-size: 16px;
            border: 2px solid #444;
            border-radius: 25px;
            background: rgba(20, 20, 20, 0.9);
            color: #fff;
            width: 400px;
            outline: none;
            transition: all 0.3s;
        }
        #search-input:focus {
            border-color: #888;
            background: rgba(30, 30, 30, 0.95);
        }
        #search-results {
            margin-top: 8px;
            background: rgba(20, 20, 20, 0.95);
            border-radius: 10px;
            max-height: 300px;
            overflow-y: auto;
            display: none;
        }
        .search-result-item {
            padding: 10px 20px;
            cursor: pointer;
            border-bottom: 1px solid #333;
            display: flex;
            align-items: center;
            gap: 12px;
            color: #fff;
        }
        .search-result-item:hover {
            background: rgba(50, 50, 50, 0.8);
        }
        .color-swatch {
            width: 30px;
            height: 30px;
            border-radius: 5px;
            border: 1px solid #666;
        }
        .color-info {
            flex: 1;
        }
        .color-name {
            font-weight: 600;
        }
        .color-hex {
            font-size: 12px;
            color: #aaa;
        }
        #loading {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            color: #fff;
            font-size: 24px;
            z-index: 1000;
            text-align: center;
        }
        #loading-bar-container {
            width: 300px;
            height: 20px;
            background: rgba(50, 50, 50, 0.8);
            border-radius: 10px;
            margin-top: 20px;
            overflow: hidden;
        }
        #loading-bar {
            width: 0%;
            height: 100%;
            background: linear-gradient(90deg, #4a9eff, #7ec8ff);
            transition: width 0.3s;
        }
        #loading-status {
            margin-top: 10px;
            font-size: 14px;
            color: #aaa;
        }
        #info {
            position: absolute;
            bottom: 20px;
            left: 20px;
            color: #aaa;
            font-size: 12px;
            background: rgba(20, 20, 20, 0.8);
            padding: 15px;
            border-radius: 8px;
            line-height: 1.6;
        }
        #tooltip {
            position: absolute;
            background: rgba(20, 20, 20, 0.95);
            color: #fff;
            padding: 10px 15px;
            border-radius: 6px;
            font-size: 14px;
            pointer-events: none;
            display: none;
            z-index: 1000;
            border: 1px solid #444;
            line-height: 1.5;
        }
        #tooltip .tooltip-name {
            font-weight: 600;
            margin-bottom: 4px;
        }
        #tooltip .tooltip-hex {
            font-family: monospace;
            color: #aaa;
            font-size: 12px;
        }
        #settings-menu {
            position: absolute;
            top: 20px;
            right: 28px;
            z-index: 200;
            user-select: none;
        }
        #settings-toggle {
            background: rgba(20,20,20,0.95);
            border: 2px solid #222;
            border-radius: 50%;
            width: 42px;
            height: 42px;
            display: flex;
            align-items: center;
            justify-content: center;
            cursor: pointer;
            transition: background 0.2s, border 0.2s;
        }
        #settings-toggle:hover {
            background: rgba(40,40,40,1);
            border-color: #666;
        }
        #settings-panel {
            display: none;
            position: absolute;
            top: 52px;
            right: 0;
            background: rgba(23,23,23,0.97);
            border: 1.5px solid #353535;
            border-radius: 10px;
            min-width: 220px;
            padding: 18px 19px 17px 19px;
            box-shadow: 0 7px 28px 0 rgba(0,0,0,0.17);
            font-size: 15px;
            color: #fff;
        }
        #settings-menu.open #settings-panel {
            display: block;
            animation: panelFadeIn 0.17s;
        }
        @keyframes panelFadeIn {
            from { opacity: 0; transform: translateY(-10px);}
            to   { opacity: 1; transform: translateY(0);}
        }
        .setting-group {
            display: flex;
            align-items: center;
            gap: 10px;
            margin-bottom: 0;
        }
        .setting-group label {
            flex: 1;
            font-size: 15px;
        }
        #scale-slider {
            flex: 2;
            accent-color: #21e1ff;
            height: 4px;
        }
        #scale-value {
            min-width: 34px;
            text-align: right;
            font-variant-numeric: tabular-nums;
            color: #8cf2ff;
        }

        @media (max-width: 600px) {
            #settings-panel { min-width: 130px; padding: 13px 11px 11px 11px;}
        }
    </style>
</head>
<body>
    <div id="loading">
        loading colors...
        <div id="loading-bar-container">
            <div id="loading-bar"></div>
        </div>
        <div id="loading-status">initializing...</div>
    </div>

    <div id="search-container" style="flex-direction:column;align-items:stretch;">
        <div style="display:flex;gap:12px;align-items:center;">
            <select id="color-space-selector">
                <option value="oklab">OKLab</option>
                <option value="rgb">RGB</option>
            </select>
            <input type="text" id="search-input" placeholder="Search by name or hex code...">
        </div>
        <div id="search-results" style="margin-top:4px;"></div>
    </div>

    <!-- INSERT_YOUR_CODE -->
    <div id="settings-menu">
        <button id="settings-toggle" title="Settings">
            <svg id="settings-gear" xmlns="http://www.w3.org/2000/svg" width="22" height="22" fill="none" viewBox="0 0 24 24"><g stroke="#fff" stroke-width="2"><circle cx="12" cy="12" r="4" fill="none"/><path d="M19.4 15a1.65 1.65 0 0 0 .33 1.82l.06.05a2 2 0 1 1-2.82 2.83l-.05-.06a1.65 1.65 0 0 0-1.82-.33c-.6.25-1.25.39-1.9.39s-1.3-.14-1.9-.39a1.65 1.65 0 0 0-1.82.33l-.05.06a2 2 0 1 1-2.83-2.83l.06-.05a1.65 1.65 0 0 0 .33-1.82c-.25-.6-.39-1.25-.39-1.9s.14-1.3.39-1.9a1.65 1.65 0 0 0-.33-1.82l-.06-.05A2 2 0 1 1 5.05 5.05l.05.06a1.65 1.65 0 0 0 1.82.33c.6-.25 1.25-.39 1.9-.39s1.3.14 1.9.39a1.65 1.65 0 0 0 1.82-.33l.05-.06a2 2 0 1 1 2.83 2.83l-.06.05a1.65 1.65 0 0 0-.33 1.82c.25.6.39 1.25.39 1.9s-.14 1.3-.39 1.9Z" fill="none"/></g></svg>
        </button>
        <div id="settings-panel">
            <div class="setting-group">
                <label for="scale-slider">Sphere scale</label>
                <input id="scale-slider" type="range" min="0.1" max="5" step="0.01" value="1" />
                <span id="scale-value">1.00</span>
            </div>
        </div>
    </div>


    
    <div id="info">
        <strong>Controls:</strong><br>
        Right-click + drag: Orbit camera<br>
        Scroll: Zoom in/out<br>
        Click color: Jump to color<br>
        WASD: Move orbit point<br>
        Space/Ctrl: Move orbit point up/down
    </div>

    <div id="tooltip">
        <div class="tooltip-name"></div>
        <div class="tooltip-hex"></div>
    </div>

    <div id="canvas-container"></div>

    <script type="importmap">
    {
        "imports": {
            "three": "https://cdn.jsdelivr.net/npm/three@0.160.0/build/three.module.js"
        }
    }
    </script>

    <script type="module">
        import * as THREE from 'three';

        // global vars
        let scene, camera, renderer;
        let colorData = [];
        let instancedMesh = null;
        let orbitPoint = new THREE.Vector3(0, 0, 0);
        let cameraDistance = 2.5;
        let cameraAngles = { theta: 0, phi: Math.PI / 4 };
        let isDragging = false;
        let previousMousePosition = { x: 0, y: 0 };
        let keys = {};
        let selectedColor = null;
        let selectedColorIndex = -1;
        let targetOrbitPoint = new THREE.Vector3(0, 0, 0);
        let targetCameraDistance = 2.5;
        let isAnimatingOrbitPoint = false;
        let isAnimatingDistance = false;
        let scale = 1.0;

        // current color space
        let currentColorSpace = null;
        
        // color space definitions
        const colorSpaces = {
            oklab: {
                name: 'OKLab',
                scale: 4.0,  // Uniform scale factor for all axes
                getPosition: (color) => {
                    return {
                        x: ((color.l - 0.5) * 1.0) * scale,  // L: 0-1, center at 0.5
                        y: (color.a * 2.5) * scale,          // a: already centered around 0
                        z: (color.oklab_b * 2.5) * scale     // b: already centered around 0
                    };
                },
                scales: { x: 1.0, y: 2.5, z: 2.5 },
                axisLabels: { x: 'L', y: 'A', z: 'B' }
            },
            rgb: {
                name: 'RGB',
                scale: 4.0,  // Uniform scale factor for all axes
                getPosition: (color) => {
                    return {
                        x: (color.r - 127.5) / 255 * scale,  // R: 0-255, center at 127.5
                        y: (color.g - 127.5) / 255 * scale,  // G: 0-255, center at 127.5
                        z: (color.b - 127.5) / 255 * scale   // B: 0-255, center at 127.5
                    };
                },
                scales: { x: 2.0, y: 2.0, z: 2.0 },
                axisLabels: { x: 'R', y: 'G', z: 'B' }
            }
        };
        
        // helper function to convert hex to RGB
        function hexToRgb(hex) {
            const result = /^#?([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})$/i.exec(hex);
            return result ? {
                r: parseInt(result[1], 16),
                g: parseInt(result[2], 16),
                b: parseInt(result[3], 16)
            } : { r: 0, g: 0, b: 0 };
        }

        function init() {
            scene = new THREE.Scene();
            scene.background = new THREE.Color(0x0a0a0a);

            camera = new THREE.PerspectiveCamera(
                75,
                window.innerWidth / window.innerHeight,
                0.01,
                1000
            );

            renderer = new THREE.WebGLRenderer({ antialias: true, logarithmicDepthBuffer: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.setPixelRatio(window.devicePixelRatio);
            document.getElementById('canvas-container').appendChild(renderer.domElement);

            const ambientLight = new THREE.AmbientLight(0xffffff, 0.6);
            scene.add(ambientLight);

            const pointLight = new THREE.PointLight(0xffffff, 0.8);
            pointLight.position.set(10, 10, 10);
            scene.add(pointLight);

            const axesHelper = new THREE.AxesHelper(1);
            scene.add(axesHelper);

            setupEventListeners();

            updateCameraPosition();
        }

        // update loading progress
        function updateLoadingProgress(percent, status) {
            const loadingBar = document.getElementById('loading-bar');
            const loadingStatus = document.getElementById('loading-status');
            if (loadingBar) loadingBar.style.width = percent + '%';
            if (loadingStatus) loadingStatus.textContent = status;
        }

        // laod colours
        async function loadColors() {
            try {
                updateLoadingProgress(10, 'Fetching CSV file...');
                const response = await fetch('colors_oklab.csv');

                if (!response.ok) {
                    throw new Error(`HTTP error! status: ${response.status}`);
                }

                updateLoadingProgress(30, 'Reading file data...');
                const text = await response.text();

                updateLoadingProgress(40, 'Parsing colors...');
                const lines = text.split('\n');
                const totalLines = lines.length;

                // skip header
                for (let i = 1; i < totalLines; i++) {
                    const line = lines[i].trim();
                    if (!line) continue;

                    const parts = line.split(',');
                    if (parts.length >= 5) {
                        const hex = parts[1];
                        const rgb = hexToRgb(hex);
                        colorData.push({
                            name: parts[0],
                            hex: hex,
                            l: parseFloat(parts[2]),
                            a: parseFloat(parts[3]),
                            oklab_b: parseFloat(parts[4]),
                            r: rgb.r,
                            g: rgb.g,
                            b: rgb.b,
                            flag: JSON.parse(parts[5])
                        });
                    }

                    // update progress every 1000 lines
                    if (i % 1000 === 0) {
                        const progress = 40 + (i / totalLines) * 30;
                        updateLoadingProgress(progress, `parsing colors... ${i}/${totalLines}`);
                        // allow UI to update
                        await new Promise(resolve => setTimeout(resolve, 0));
                    }
                }

                updateLoadingProgress(70, `Loaded ${colorData.length} colors. creating spheres...`);
                console.log(`loaded ${colorData.length} colors`);

                // set default color space
                currentColorSpace = colorSpaces.oklab;
                await createColorSpheres();

                updateLoadingProgress(100, 'Complete!');
                setTimeout(() => {
                    document.getElementById('loading').style.display = 'none';
                }, 500);
            } catch (error) {
                console.error('Error loading colors:', error);
                const loadingDiv = document.getElementById('loading');
                loadingDiv.innerHTML = `
                    <div style="color: #ff5555;">Error loading colors!</div>
                    <div style="font-size: 14px; margin-top: 10px; color: #aaa;">
                        ${error.message}<br><br>
                        make sure you're running this from a local web server<br>
                        (e.g., <code>python -m http.server 8000</code>)
                    </div>
                `;
            }
        }

        // create instanced mesh for all colours
        async function createColorSpheres() {
            const totalColors = colorData.length;

            const geometry = new THREE.SphereGeometry(0.004, 8, 6);

            const material = new THREE.MeshBasicMaterial();

            instancedMesh = new THREE.InstancedMesh(geometry, material, totalColors);

            await updateSpherePositions();

            scene.add(instancedMesh);

            console.log(`created instanced mesh with ${totalColors} instances`);
        }

        // update sphere positions based on current color space
        async function updateSpherePositions() {
            if (!instancedMesh || !currentColorSpace) return;

            const totalColors = colorData.length;
            const dummy = new THREE.Object3D();
            const color = new THREE.Color();

            for (let i = 0; i < totalColors; i++) {
                const colorData_item = colorData[i];
                const pos = currentColorSpace.getPosition(colorData_item);

                dummy.position.set(pos.x, pos.y, pos.z);
                dummy.updateMatrix();
                instancedMesh.setMatrixAt(i, dummy.matrix);

                color.set(colorData_item.hex);
                instancedMesh.setColorAt(i, color);

                if (i % 1000 === 0) {
                    const progress = 70 + (i / totalColors) * 30;
                    updateLoadingProgress(progress, `updating positions... ${i}/${totalColors}`);

                    await new Promise(resolve => setTimeout(resolve, 0));
                }
            }

            instancedMesh.instanceMatrix.needsUpdate = true;
            instancedMesh.instanceColor.needsUpdate = true;

            // reset selection when switching color spaces
            if (selectedColorIndex >= 0) {
                const dummy = new THREE.Object3D();
                dummy.scale.set(1, 1, 1);
                instancedMesh.getMatrixAt(selectedColorIndex, dummy.matrix);
                dummy.matrix.decompose(dummy.position, dummy.quaternion, dummy.scale);
                dummy.scale.set(1, 1, 1);
                dummy.updateMatrix();
                instancedMesh.setMatrixAt(selectedColorIndex, dummy.matrix);
                instancedMesh.instanceMatrix.needsUpdate = true;
                selectedColorIndex = -1;
                selectedColor = null;
            }

            // reset orbit point to center
            orbitPoint.set(0, 0, 0);
            targetOrbitPoint.set(0, 0, 0);
            cameraDistance = 2.5;
            targetCameraDistance = 2.5;

            console.log(`updated positions using ${currentColorSpace.name} color space`);
        }

        function updateCameraPosition() {
            const x = orbitPoint.x + cameraDistance * Math.sin(cameraAngles.phi) * Math.cos(cameraAngles.theta);
            const y = orbitPoint.y + cameraDistance * Math.cos(cameraAngles.phi);
            const z = orbitPoint.z + cameraDistance * Math.sin(cameraAngles.phi) * Math.sin(cameraAngles.theta);

            camera.position.set(x, y, z);
            camera.lookAt(orbitPoint);
        }

        // Reusable vector for screen-space picking
        const tempVector = new THREE.Vector3();

        // Find the closest color to a ray within a screen-space pixel threshold
        function findClosestColorToRay(mouseX, mouseY, pixelThreshold = 10) {
            if (!currentColorSpace || colorData.length === 0) return -1;

            let closestIndex = -1;
            let closestScreenDist = pixelThreshold;

            for (let i = 0; i < colorData.length; i++) {
                const pos = currentColorSpace.getPosition(colorData[i]);
                tempVector.set(pos.x, pos.y, pos.z);

                // Project to screen space
                tempVector.project(camera);

                // Convert to pixel coordinates
                const screenX = (tempVector.x * 0.5 + 0.5) * window.innerWidth;
                const screenY = (-tempVector.y * 0.5 + 0.5) * window.innerHeight;

                // Check if point is in front of camera (z < 1 after projection)
                if (tempVector.z > 1) continue;

                // Calculate screen distance
                const dx = screenX - mouseX;
                const dy = screenY - mouseY;
                const screenDist = Math.sqrt(dx * dx + dy * dy);

                if (screenDist < closestScreenDist) {
                    closestScreenDist = screenDist;
                    closestIndex = i;
                }
            }

            return closestIndex;
        }
        
        function handleColorClick(event) {
            if (!instancedMesh) return;

            const instanceId = findClosestColorToRay(event.clientX, event.clientY, 15);

            if (instanceId >= 0) {
                const color = colorData[instanceId];
                jumpToColor(color, instanceId);
            }
        }

        function jumpToColor(color, instanceId) {
            if (!currentColorSpace) return;
            
            const pos = currentColorSpace.getPosition(color);
            targetOrbitPoint.set(pos.x, pos.y, pos.z);
            targetCameraDistance = 0.2;
            isAnimatingOrbitPoint = true;
            isAnimatingDistance = true;
            
            // reset previous selection
            if (selectedColorIndex >= 0 && instancedMesh) {
                const dummy = new THREE.Object3D();
                dummy.scale.set(1, 1, 1);
                instancedMesh.getMatrixAt(selectedColorIndex, dummy.matrix);
                dummy.matrix.decompose(dummy.position, dummy.quaternion, dummy.scale);
                dummy.scale.set(1, 1, 1);
                dummy.updateMatrix();
                instancedMesh.setMatrixAt(selectedColorIndex, dummy.matrix);
                instancedMesh.instanceMatrix.needsUpdate = true;
            }

            // highlight the new selection
            selectedColor = color;
            selectedColorIndex = instanceId;

            if (instancedMesh && instanceId >= 0) {
                const dummy = new THREE.Object3D();
                instancedMesh.getMatrixAt(instanceId, dummy.matrix);
                dummy.matrix.decompose(dummy.position, dummy.quaternion, dummy.scale);
                dummy.scale.set(2.4, 2.4, 2.4);
                dummy.updateMatrix();
                instancedMesh.setMatrixAt(instanceId, dummy.matrix);
                instancedMesh.instanceMatrix.needsUpdate = true;
            }

            console.log(`Selected: ${color.name} (${color.hex})`);
        }

        // smoothly moves the camera
        // separated target variables for orbit point and distance so that
        // the distance animation can be cancelled if we get a mouse wheel event
        function animate() {
            requestAnimationFrame(animate);

            if (isAnimatingOrbitPoint) {
                orbitPoint.lerp(targetOrbitPoint, 0.1);
                if (orbitPoint.distanceTo(targetOrbitPoint) < 0.001) {
                    isAnimatingOrbitPoint = false;
                }
            }

            if (isAnimatingDistance) {
                cameraDistance += (targetCameraDistance - cameraDistance) * 0.1;
                if (Math.abs(targetCameraDistance - cameraDistance) < 0.001) {
                    isAnimatingDistance = false;
                }
            }

            // keyboard movement
            handleKeyboardMovement();

            updateCameraPosition();

            renderer.render(scene, camera);
        }

        // Throttle tooltip updates for performance
        let lastTooltipUpdate = 0;
        const tooltipThrottleMs = 50;

        function updateTooltip(event) {
            if (!instancedMesh) return;

            const now = performance.now();
            if (now - lastTooltipUpdate < tooltipThrottleMs) return;
            lastTooltipUpdate = now;

            const tooltip = document.getElementById('tooltip');
            const tooltipName = tooltip.querySelector('.tooltip-name');
            const tooltipHex = tooltip.querySelector('.tooltip-hex');

            const instanceId = findClosestColorToRay(event.clientX, event.clientY, 15);

            if (instanceId >= 0) {
                const color = colorData[instanceId];

                tooltipName.textContent = color.name;
                tooltipHex.textContent = color.hex;

                tooltip.style.display = 'block';
                tooltip.style.left = (event.clientX + 15) + 'px';
                tooltip.style.top = (event.clientY + 15) + 'px';
            } else {
                tooltip.style.display = 'none';
            }
        }

        function handleKeyboardMovement() {
            const moveSpeed = 0.01;

            if (keys['w'] || keys['W']) orbitPoint.z -= moveSpeed;
            if (keys['s'] || keys['S']) orbitPoint.z += moveSpeed;
            if (keys['a'] || keys['A']) orbitPoint.x -= moveSpeed;
            if (keys['d'] || keys['D']) orbitPoint.x += moveSpeed;
            if (keys[' ']) orbitPoint.y += moveSpeed;
            if (keys['Control']) orbitPoint.y -= moveSpeed;
        }

        function setupEventListeners() {
            // Mouse controls
            renderer.domElement.addEventListener('mousedown', onMouseDown);
            renderer.domElement.addEventListener('mousemove', onMouseMove);
            renderer.domElement.addEventListener('mouseup', onMouseUp);
            renderer.domElement.addEventListener('wheel', onMouseWheel);
            renderer.domElement.addEventListener('contextmenu', (e) => e.preventDefault());

            // Keyboard controls
            window.addEventListener('keydown', (e) => {
                keys[e.key] = true;
            });
            window.addEventListener('keyup', (e) => {
                keys[e.key] = false;
            });

            // Window resize
            window.addEventListener('resize', onWindowResize);

            // Search
            const searchInput = document.getElementById('search-input');
            const searchResults = document.getElementById('search-results');

            searchInput.addEventListener('input', (e) => {
                const query = e.target.value.trim().toLowerCase();

                if (query.length < 2) {
                    searchResults.style.display = 'none';
                    return;
                }

                const matches = colorData.filter(color =>
                    color.name.toLowerCase().includes(query) ||
                    color.hex.toLowerCase().includes(query)
                ).slice(0, 10);

                if (matches.length > 0) {
                    searchResults.innerHTML = matches.map(color => `
                        <div class="search-result-item" data-name="${color.name}">
                            <div class="color-swatch" style="background-color: ${color.hex}"></div>
                            <div class="color-info">
                                <div class="color-name">${color.name}</div>
                                <div class="color-hex">${color.hex}</div>
                            </div>
                        </div>
                    `).join('');
                    searchResults.style.display = 'block';

                    // Add click handlers
                    searchResults.querySelectorAll('.search-result-item').forEach(item => {
                        item.addEventListener('click', () => {
                            const colorName = item.getAttribute('data-name');
                            const colorIndex = colorData.findIndex(c => c.name === colorName);
                            if (colorIndex >= 0) {
                                jumpToColor(colorData[colorIndex], colorIndex);
                                searchInput.value = '';
                                searchResults.style.display = 'none';
                            }
                        });
                    });
                } else {
                    searchResults.style.display = 'none';
                }
            });

            searchInput.addEventListener('blur', () => {
                setTimeout(() => {
                    searchResults.style.display = 'none';
                }, 200);
            });

            // Color space selector
            const colorSpaceSelector = document.getElementById('color-space-selector');
            colorSpaceSelector.addEventListener('change', async (e) => {
                const selectedSpace = e.target.value;
                if (colorSpaces[selectedSpace]) {
                    currentColorSpace = colorSpaces[selectedSpace];
                    document.getElementById('loading').style.display = 'block';
                    updateLoadingProgress(0, `Switching to ${currentColorSpace.name}...`);
                    await updateSpherePositions();
                    updateLoadingProgress(100, 'Complete!');
                    setTimeout(() => {
                        document.getElementById('loading').style.display = 'none';
                    }, 500);
                }
            });

            // Settings menu
            const settingsMenu = document.getElementById('settings-menu');
            const settingsToggle = document.getElementById('settings-toggle');
            
            settingsToggle.addEventListener('click', (e) => {
                e.stopPropagation();
                settingsMenu.classList.toggle('open');
            });

            // Close menu when clicking outside
            document.addEventListener('mousedown', (e) => {
                if (!settingsMenu.contains(e.target)) {
                    settingsMenu.classList.remove('open');
                }
            });

            // Close menu on Escape key
            window.addEventListener('keydown', (e) => {
                if (e.key === 'Escape') {
                    settingsMenu.classList.remove('open');
                }
            });

            // Scale slider
            const scaleSlider = document.getElementById('scale-slider');
            const scaleValue = document.getElementById('scale-value');
            
            // Initialize scale from slider and display
            scale = parseFloat(scaleSlider.value);
            scaleValue.textContent = scale.toFixed(2);

            scaleSlider.addEventListener('input', async () => {
                scale = parseFloat(scaleSlider.value);
                scaleValue.textContent = scale.toFixed(2);
                
                // Update sphere positions with new scale
                if (instancedMesh && currentColorSpace) {
                    await updateSpherePositions();
                }
            });
        }

        // events

        function onMouseDown(event) {
            if (event.button === 2) { // Right click
                isDragging = true;
                previousMousePosition = { x: event.clientX, y: event.clientY };
            } else if (event.button === 0) { // Left click
                handleColorClick(event);
            }
        }

        function onMouseMove(event) {
            if (isDragging) {
                const deltaX = event.clientX - previousMousePosition.x;
                const deltaY = event.clientY - previousMousePosition.y;

                cameraAngles.theta += deltaX * 0.005;
                cameraAngles.phi += deltaY * 0.005;

                // Clamp phi to prevent gimbal lock
                cameraAngles.phi = Math.max(0.1, Math.min(Math.PI - 0.1, cameraAngles.phi));

                previousMousePosition = { x: event.clientX, y: event.clientY };
            } else {
                // Handle tooltip on hover
                updateTooltip(event);
            }
        }

        function onMouseUp(event) {
            if (event.button === 2) {
                isDragging = false;
            }
        }

        function onMouseWheel(event) {
            event.preventDefault();
            
            if (isAnimatingDistance) {
                isAnimatingDistance = false;
            }
            
            const delta = event.deltaY * 0.001;
            cameraDistance = Math.max(0.1, Math.min(10, cameraDistance + delta));
        }

        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        }

        init();
        loadColors();
        animate();
    </script>
</body>
</html>
