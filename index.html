<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Colour Explorer</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            overflow: hidden;
            background: #000;
        }
        #canvas-container {
            width: 100vw;
            height: 100vh;
        }
        #search-container {
            position: absolute;
            top: 20px;
            left: 50%;
            transform: translateX(-50%);
            z-index: 100;
            display: flex;
            gap: 12px;
            align-items: center;
        }
        #color-space-selector {
            padding: 12px 20px;
            font-size: 16px;
            border: 2px solid #444;
            border-radius: 25px;
            background: rgba(20, 20, 20, 0.9);
            color: #fff;
            outline: none;
            cursor: pointer;
            transition: all 0.3s;
        }
        #color-space-selector:hover {
            border-color: #888;
            background: rgba(30, 30, 30, 0.95);
        }
        #color-space-selector:focus {
            border-color: #888;
            background: rgba(30, 30, 30, 0.95);
        }
        #search-input {
            padding: 12px 20px;
            font-size: 16px;
            border: 2px solid #444;
            border-radius: 25px;
            background: rgba(20, 20, 20, 0.9);
            color: #fff;
            width: 400px;
            outline: none;
            transition: all 0.3s;
        }
        #search-input:focus {
            border-color: #888;
            background: rgba(30, 30, 30, 0.95);
        }
        #search-results {
            margin-top: 8px;
            background: rgba(20, 20, 20, 0.95);
            border-radius: 10px;
            max-height: 300px;
            overflow-y: auto;
            display: none;
        }
        .search-result-item {
            padding: 10px 20px;
            cursor: pointer;
            border-bottom: 1px solid #333;
            display: flex;
            align-items: center;
            gap: 12px;
            color: #fff;
        }
        .search-result-item:hover,
        .search-result-item.selected {
            background: rgba(70, 70, 70, 0.9);
        }
        .color-swatch {
            width: 30px;
            height: 30px;
            border-radius: 5px;
            border: 1px solid #666;
        }
        .color-info {
            flex: 1;
        }
        .color-name {
            font-weight: 600;
        }
        .color-hex {
            font-size: 12px;
            color: #aaa;
        }
        #loading {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            color: #fff;
            font-size: 24px;
            z-index: 1000;
            text-align: center;
        }
        #loading-bar-container {
            width: 300px;
            height: 20px;
            background: rgba(50, 50, 50, 0.8);
            border-radius: 10px;
            margin-top: 20px;
            overflow: hidden;
        }
        #loading-bar {
            width: 0%;
            height: 100%;
            background: linear-gradient(90deg, #4a9eff, #7ec8ff);
            transition: width 0.3s;
        }
        #loading-status {
            margin-top: 10px;
            font-size: 14px;
            color: #aaa;
        }
        #info {
            position: absolute;
            bottom: 20px;
            left: 20px;
            color: #aaa;
            font-size: 12px;
            background: rgba(20, 20, 20, 0.8);
            padding: 15px;
            border-radius: 8px;
            line-height: 1.6;
        }
        #tooltip {
            position: absolute;
            background: rgba(20, 20, 20, 0.95);
            color: #fff;
            padding: 10px 15px;
            border-radius: 6px;
            font-size: 14px;
            pointer-events: none;
            display: none;
            z-index: 1000;
            border: 1px solid #444;
            line-height: 1.5;
        }
        #tooltip .tooltip-name {
            font-weight: 600;
            margin-bottom: 4px;
        }
        #tooltip .tooltip-hex {
            font-family: monospace;
            color: #aaa;
            font-size: 12px;
        }
        #settings-menu {
            position: absolute;
            top: 20px;
            right: 28px;
            z-index: 200;
            user-select: none;
        }
        #settings-toggle {
            background: rgba(20,20,20,0.95);
            border: 2px solid #222;
            border-radius: 50%;
            width: 42px;
            height: 42px;
            display: flex;
            align-items: center;
            justify-content: center;
            cursor: pointer;
            transition: background 0.2s, border 0.2s;
        }
        #settings-toggle:hover {
            background: rgba(40,40,40,1);
            border-color: #666;
        }
        #settings-panel {
            display: none;
            position: absolute;
            top: 52px;
            right: 0;
            background: rgba(23,23,23,0.97);
            border: 1.5px solid #353535;
            border-radius: 10px;
            min-width: 220px;
            padding: 18px 19px 17px 19px;
            box-shadow: 0 7px 28px 0 rgba(0,0,0,0.17);
            font-size: 15px;
            color: #fff;
        }
        #settings-menu.open #settings-panel {
            display: block;
            animation: panelFadeIn 0.17s;
        }
        @keyframes panelFadeIn {
            from { opacity: 0; transform: translateY(-10px);}
            to   { opacity: 1; transform: translateY(0);}
        }
        .setting-group {
            display: flex;
            align-items: center;
            gap: 10px;
            margin-bottom: 0;
        }
        .setting-group label {
            flex: 1;
            font-size: 15px;
        }
        #scale-slider, #background-red, #background-green, #background-blue {
            flex: 2;
            accent-color: #c0c0c0;
            height: 4px;
        }
        #scale-value {
            min-width: 34px;
            text-align: right;
            font-variant-numeric: tabular-nums;
            color: #ffffff;
        }
        #hide-unflagged-checkbox {
            accent-color: #c0c0c0;
            cursor: pointer;
            width: 18px;
            height: 18px;
        }

        @media (max-width: 600px) {
            #settings-panel { min-width: 130px; padding: 13px 11px 11px 11px;}
        }
    </style>
</head>
<body>
    <div id="loading">
        loading colors...
        <div id="loading-bar-container">
            <div id="loading-bar"></div>
        </div>
        <div id="loading-status">initializing...</div>
    </div>

    <div id="search-container" style="flex-direction:column;align-items:stretch;">
        <div style="display:flex;gap:12px;align-items:center;">
            <select id="color-space-selector">
                <option value="oklab">Oklab</option>
                <option value="rgb">RGB</option>
            </select>
            <input type="text" id="search-input" placeholder="Search by name or hex code...">
        </div>
        <div id="search-results" style="margin-top:4px;"></div>
    </div>

    <div id="settings-menu">
        <button id="settings-toggle" title="Settings">
            <img id="settings-gear" src="settings.svg" width="90" height="22" alt="Settings">
        </button>
        <div id="settings-panel">
            <div class="setting-group">
                <label for="scale-slider">Sphere scale</label>
                <input id="scale-slider" type="range" min="0.1" max="5" step="0.01" value="1" />
                <span id="scale-value">1.00</span>
            </div>
            <div class="setting-group">
                <label for="background-red">Background Red</label>
                <input id="background-red" type="range" min="0" max="255" step="1" value="2" />
                <span id="background-red-value">2</span>
            </div>
            <div class="setting-group">
                <label for="background-green">Background Green</label>
                <input id="background-green" type="range" min="0" max="255" step="1" value="2" />
                <span id="background-green-value">2</span>
            </div>
            <div class="setting-group">
                <label for="background-blue">Background Blue</label>
                <input id="background-blue" type="range" min="0" max="255" step="1" value="2" />
                <span id="background-blue-value">2</span>
            </div>
            <div class="setting-group" style="margin-top: 12px;">
                <label for="hide-unflagged-checkbox" style="flex: 1; cursor: pointer;">Hide unflagged colors</label>
                <input id="hide-unflagged-checkbox" type="checkbox" />
            </div>
        </div>
    </div>


    
    <div id="info">
        <strong>Controls:</strong><br>
        Right-click + drag: Orbit camera<br>
        Scroll: Zoom in/out<br>
        Click color: Jump to color<br>
        WASD: Move orbit point<br>
        Space/Ctrl: Move orbit point up/down
    </div>

    <div id="tooltip">
        <div class="tooltip-name"></div>
        <div class="tooltip-hex"></div>
    </div>

    <div id="canvas-container"></div>

    <script type="importmap">
    {
        "imports": {
            "three": "https://cdn.jsdelivr.net/npm/three@0.160.0/build/three.module.js"
        }
    }
    </script>

    <script type="module">
        import * as THREE from 'three';

        // global vars
        let scene, camera, renderer;
        let colorData = [];
        let instancedMesh = null;
        let orbitPoint = new THREE.Vector3(0, 0, 0);
        let cameraDistance = 2.5;
        let cameraAngles = { theta: 0, phi: Math.PI / 4 };
        let isDragging = false;
        let previousMousePosition = { x: 0, y: 0 };
        let keys = {};
        let selectedColor = null;
        let selectedColorIndex = -1;
        let targetOrbitPoint = new THREE.Vector3(0, 0, 0);
        let targetCameraDistance = 2.5;
        let isAnimatingOrbitPoint = false;
        let isAnimatingDistance = false;
        let scale = 1.0;
        let pixelThreshold = 8;

        let hideUnflaggedColors = false;

        let backgroundRed = 2
        let backgroundGreen = 2
        let backgroundBlue = 2

        // GPU picking setup
        let pickingMesh = null;
        let pickingRenderTarget = null;
        let pickingMaterial = null;

        // current color space
        let currentColorSpace = null;
        
        // color space definitions
        const colorSpaces = {
            oklab: {
                name: 'Oklab',
                scale: 4.0,  // Uniform scale factor for all axes
                getPosition: (color) => {
                    return {
                        x: ((color.l - 0.5) * 1.0) * scale,  // L: 0-1, center at 0.5
                        y: (color.a * 2.5) * scale,          // a: already centered around 0
                        z: (color.oklab_b * 2.5) * scale     // b: already centered around 0
                    };
                },
                scales: { x: 1.0, y: 2.5, z: 2.5 },
                axisLabels: { x: 'L', y: 'A', z: 'B' }
            },
            rgb: {
                name: 'RGB',
                scale: 4.0,  // Uniform scale factor for all axes
                getPosition: (color) => {
                    return {
                        x: (color.r - 127.5) / 255 * scale,  // R: 0-255, center at 127.5
                        y: (color.g - 127.5) / 255 * scale,  // G: 0-255, center at 127.5
                        z: (color.b - 127.5) / 255 * scale   // B: 0-255, center at 127.5
                    };
                },
                scales: { x: 2.0, y: 2.0, z: 2.0 },
                axisLabels: { x: 'R', y: 'G', z: 'B' }
            }
        };
        
        // helper function to convert hex to RGB
        function hexToRgb(hex) {
            const result = /^#?([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})$/i.exec(hex);
            return result ? {
                r: parseInt(result[1], 16),
                g: parseInt(result[2], 16),
                b: parseInt(result[3], 16)
            } : { r: 0, g: 0, b: 0 };
        }

        function init() {
            scene = new THREE.Scene();
            updateSceneBackground();

            camera = new THREE.PerspectiveCamera(
                75,
                window.innerWidth / window.innerHeight,
                0.01,
                1000
            );

            renderer = new THREE.WebGLRenderer({ antialias: true, logarithmicDepthBuffer: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.setPixelRatio(window.devicePixelRatio);
            document.getElementById('canvas-container').appendChild(renderer.domElement);

            const ambientLight = new THREE.AmbientLight(0xffffff, 0.6);
            scene.add(ambientLight);

            const pointLight = new THREE.PointLight(0xffffff, 0.8);
            pointLight.position.set(10, 10, 10);
            scene.add(pointLight);

            const axesHelper = new THREE.AxesHelper(1);
            scene.add(axesHelper);

            setupEventListeners();

            updateCameraPosition();
        }

        // update loading progress
        function updateLoadingProgress(percent, status) {
            const loadingBar = document.getElementById('loading-bar');
            const loadingStatus = document.getElementById('loading-status');
            if (loadingBar) loadingBar.style.width = percent + '%';
            if (loadingStatus) loadingStatus.textContent = status;
        }

        // laod colours
        async function loadColors() {
            try {
                updateLoadingProgress(10, 'Fetching CSV file...');
                const response = await fetch('colors_oklab.csv');

                if (!response.ok) {
                    throw new Error(`HTTP error! status: ${response.status}`);
                }

                updateLoadingProgress(30, 'Reading file data...');
                const text = await response.text();

                updateLoadingProgress(40, 'Parsing colors...');
                const lines = text.split('\n');
                const totalLines = lines.length;

                // skip header
                for (let i = 1; i < totalLines; i++) {
                    const line = lines[i].trim();
                    if (!line) continue;

                    const parts = line.split(',');
                    if (parts.length >= 5) {
                        const hex = parts[1];
                        const rgb = hexToRgb(hex);
                        colorData.push({
                            name: parts[0],
                            hex: hex,
                            l: parseFloat(parts[2]),
                            a: parseFloat(parts[3]),
                            oklab_b: parseFloat(parts[4]),
                            r: rgb.r,
                            g: rgb.g,
                            b: rgb.b,
                            flag: JSON.parse(parts[5]),
                        });
                    }

                    // update progress every 1000 lines
                    if (i % 1000 === 0) {
                        const progress = 40 + (i / totalLines) * 30;
                        updateLoadingProgress(progress, `parsing colors... ${i}/${totalLines}`);
                        // allow UI to update
                        await new Promise(resolve => setTimeout(resolve, 0));
                    }
                }

                updateLoadingProgress(70, `Loaded ${colorData.length} colors. creating spheres...`);
                console.log(`loaded ${colorData.length} colors`);

                // set default color space
                currentColorSpace = colorSpaces.oklab;
                await createColorSpheres();

                updateLoadingProgress(100, 'Complete!');
                setTimeout(() => {
                    document.getElementById('loading').style.display = 'none';
                }, 500);
            } catch (error) {
                console.error('Error loading colors:', error);
                const loadingDiv = document.getElementById('loading');
                loadingDiv.innerHTML = `
                    <div style="color: #ff5555;">Error loading colors!</div>
                    <div style="font-size: 14px; margin-top: 10px; color: #aaa;">
                        ${error.message}<br><br>
                        make sure you're running this from a local web server<br>
                        (e.g., <code>python -m http.server 8000</code>)
                    </div>
                `;
            }
        }

        // create instanced mesh for all colours
        async function createColorSpheres() {
            const totalColors = colorData.length;

            const geometry = new THREE.SphereGeometry(0.004, 16, 12);

            const material = new THREE.MeshBasicMaterial();

            instancedMesh = new THREE.InstancedMesh(geometry, material, totalColors);
            instancedMesh.frustumCulled = false;  // Disable culling - instances spread far from origin

            // Create GPU picking system
            pickingRenderTarget = new THREE.WebGLRenderTarget(1, 1);
            pickingMaterial = new THREE.MeshBasicMaterial();
            pickingMesh = new THREE.InstancedMesh(geometry, pickingMaterial, totalColors);
            pickingMesh.frustumCulled = false;
            pickingMesh.visible = false; // Hidden, only rendered to pick buffer

            await updateSpherePositions();

            scene.add(instancedMesh);
            scene.add(pickingMesh);

            console.log(`created instanced mesh with ${totalColors} instances`);
        }

        // Encode instance index as RGB color (offset by 1 so black=0 means "no hit")
        // Index 0 becomes color (1,0,0), index 1 becomes (1,0,1), etc.
        function indexToColor(index) {
            const encoded = index + 1; // Offset by 1 so 0 is never used
            const r = ((encoded >> 16) & 0xff) / 255;
            const g = ((encoded >> 8) & 0xff) / 255;
            const b = (encoded & 0xff) / 255;
            return new THREE.Color(r, g, b);
        }

        // Decode RGB color back to instance index
        function colorToIndex(r, g, b) {
            const encoded = (r << 16) | (g << 8) | b;
            return encoded - 1; // Remove offset
        }

        // efficiently update visibility of unflagged colors
        function updateUnflaggedVisibility() {
            if (!instancedMesh) return;

            const totalColors = colorData.length;
            const dummy = new THREE.Object3D();
            let needsUpdate = false;

            for (let i = 0; i < totalColors; i++) {
                const colorData_item = colorData[i];
                const shouldHide = hideUnflaggedColors && !colorData_item.flag;
                
                // Skip if this is the selected color (it has special scaling)
                if (i === selectedColorIndex) continue;

                // Get current matrix
                instancedMesh.getMatrixAt(i, dummy.matrix);
                dummy.matrix.decompose(dummy.position, dummy.quaternion, dummy.scale);

                // Determine target scale
                const targetScale = shouldHide ? 0 : 1;
                
                // Only update if scale needs to change
                // Using epsilon for float comparison safety
                if (Math.abs(dummy.scale.x - targetScale) > 0.001) {
                    // If recovering from scale 0, decompose() might have produced invalid quaternion.
                    // To be safe, we recompute position and reset quaternion.
                    const pos = currentColorSpace.getPosition(colorData_item);
                    dummy.position.set(pos.x, pos.y, pos.z);
                    dummy.quaternion.identity();
                    dummy.scale.set(targetScale, targetScale, targetScale);
                    
                    dummy.updateMatrix();
                    instancedMesh.setMatrixAt(i, dummy.matrix);
                    needsUpdate = true;
                }
            }

            // Also update picking mesh visibility
            if (pickingMesh) {
                for (let i = 0; i < totalColors; i++) {
                    const colorData_item = colorData[i];
                    const shouldHide = hideUnflaggedColors && !colorData_item.flag;
                    
                    if (i === selectedColorIndex) continue;

                    pickingMesh.getMatrixAt(i, dummy.matrix);
                    dummy.matrix.decompose(dummy.position, dummy.quaternion, dummy.scale);

                    const targetScale = shouldHide ? 0 : 1;
                    
                    if (Math.abs(dummy.scale.x - targetScale) > 0.001) {
                        const pos = currentColorSpace.getPosition(colorData_item);
                        dummy.position.set(pos.x, pos.y, pos.z);
                        dummy.quaternion.identity();
                        dummy.scale.set(targetScale, targetScale, targetScale);

                        dummy.updateMatrix();
                        pickingMesh.setMatrixAt(i, dummy.matrix);
                    }
                }
                pickingMesh.instanceMatrix.needsUpdate = true;
            }

            if (needsUpdate) {
                instancedMesh.instanceMatrix.needsUpdate = true;
            }
        }

        // update sphere positions based on current color space
        async function updateSpherePositions() {
            if (!instancedMesh || !currentColorSpace) return;

            const totalColors = colorData.length;
            const dummy = new THREE.Object3D();
            const color = new THREE.Color();

            for (let i = 0; i < totalColors; i++) {
                const colorData_item = colorData[i];
                const pos = currentColorSpace.getPosition(colorData_item);

                dummy.position.set(pos.x, pos.y, pos.z);
                // Set scale based on visibility and selection
                if (i === selectedColorIndex) {
                    dummy.scale.set(2.4, 2.4, 2.4);
                } else if (hideUnflaggedColors && !colorData_item.flag) {
                    dummy.scale.set(0, 0, 0);
                } else {
                    dummy.scale.set(1, 1, 1);
                }
                dummy.updateMatrix();
                
                // Update visible mesh
                instancedMesh.setMatrixAt(i, dummy.matrix);
                color.set(colorData_item.hex);
                instancedMesh.setColorAt(i, color);

                // Update picking mesh with same position but ID-encoded color
                if (pickingMesh) {
                    pickingMesh.setMatrixAt(i, dummy.matrix);
                    const idColor = indexToColor(i);
                    pickingMesh.setColorAt(i, idColor);
                }

                if (i % 1000 === 0) {
                    const progress = 70 + (i / totalColors) * 30;
                    updateLoadingProgress(progress, `updating positions... ${i}/${totalColors}`);

                    await new Promise(resolve => setTimeout(resolve, 0));
                }
            }

            instancedMesh.instanceMatrix.needsUpdate = true;
            instancedMesh.instanceColor.needsUpdate = true;
            
            if (pickingMesh) {
                pickingMesh.instanceMatrix.needsUpdate = true;
                pickingMesh.instanceColor.needsUpdate = true;
            }

            // reset selection when switching color spaces
            if (selectedColorIndex >= 0) {
                const dummy = new THREE.Object3D();
                instancedMesh.getMatrixAt(selectedColorIndex, dummy.matrix);
                dummy.matrix.decompose(dummy.position, dummy.quaternion, dummy.scale);
                // Restore scale based on visibility setting
                const colorData_item = colorData[selectedColorIndex];
                const targetScale = (hideUnflaggedColors && !colorData_item.flag) ? 0 : 1;
                dummy.scale.set(targetScale, targetScale, targetScale);
                dummy.updateMatrix();
                instancedMesh.setMatrixAt(selectedColorIndex, dummy.matrix);
                instancedMesh.instanceMatrix.needsUpdate = true;
                
                // Also update picking mesh
                if (pickingMesh) {
                    pickingMesh.setMatrixAt(selectedColorIndex, dummy.matrix);
                    pickingMesh.instanceMatrix.needsUpdate = true;
                }
                
                selectedColorIndex = -1;
                selectedColor = null;
            }

            // reset orbit point to center
            orbitPoint.set(0, 0, 0);
            targetOrbitPoint.set(0, 0, 0);
            cameraDistance = 2.5;
            targetCameraDistance = 2.5;

            console.log(`updated positions using ${currentColorSpace.name} color space`);
        }

        function updateCameraPosition() {
            const x = orbitPoint.x + cameraDistance * Math.sin(cameraAngles.phi) * Math.cos(cameraAngles.theta);
            const y = orbitPoint.y + cameraDistance * Math.cos(cameraAngles.phi);
            const z = orbitPoint.z + cameraDistance * Math.sin(cameraAngles.phi) * Math.sin(cameraAngles.theta);

            camera.position.set(x, y, z);
            camera.lookAt(orbitPoint);
        }

        function updateSceneBackground() {
            if (scene) {
                scene.background = new THREE.Color(
                    backgroundRed / 255,
                    backgroundGreen / 255,
                    backgroundBlue / 255
                );
            }
        }

        // GPU-based picking: render picking mesh to offscreen buffer and read pixel
        function pickColorAtPixel(mouseX, mouseY) {
            if (!pickingMesh || !pickingRenderTarget) return -1;

            // Resize render target to match viewport
            const width = window.innerWidth;
            const height = window.innerHeight;
            if (pickingRenderTarget.width !== width || pickingRenderTarget.height !== height) {
                pickingRenderTarget.setSize(width, height);
            }

            // Store original state
            const originalRenderTarget = renderer.getRenderTarget();
            const originalAutoClear = renderer.autoClear;
            const originalBackground = scene.background;
            
            // Hide visible mesh, show picking mesh
            instancedMesh.visible = false;
            pickingMesh.visible = true;
            
            // Temporarily disable scene background for picking (ensures pure black = no hit)
            scene.background = null;
            
            // Render only picking mesh to offscreen buffer
            renderer.autoClear = true;
            renderer.setRenderTarget(pickingRenderTarget);
            renderer.clear();
            renderer.render(scene, camera);
            
            // Restore state
            pickingMesh.visible = false;
            instancedMesh.visible = true;
            scene.background = originalBackground;
            renderer.setRenderTarget(originalRenderTarget);
            renderer.autoClear = originalAutoClear;

            // Read pixel at mouse position
            const pixelBuffer = new Uint8Array(4);
            const readX = Math.floor(mouseX);
            const readY = height - Math.floor(mouseY) - 1; // Flip Y coordinate
            
            renderer.readRenderTargetPixels(
                pickingRenderTarget,
                readX, readY,
                1, 1,
                pixelBuffer
            );

            // Decode color to index
            const r = pixelBuffer[0];
            const g = pixelBuffer[1];
            const b = pixelBuffer[2];
            
            // If pixel is pure black (0,0,0), no object was hit
            if (r === 0 && g === 0 && b === 0) {
                return -1;
            }
            
            const index = colorToIndex(r, g, b);

            // Validate index
            if (index >= 0 && index < colorData.length) {
                return index;
            }
            
            return -1;
        }
        
        function handleColorClick(event) {
            if (!instancedMesh) return;

            const instanceId = pickColorAtPixel(event.clientX, event.clientY);

            if (instanceId >= 0) {
                const color = colorData[instanceId];
                jumpToColor(color, instanceId);
            }
        }

        function jumpToColor(color, instanceId) {
            if (!currentColorSpace) return;
            
            const pos = currentColorSpace.getPosition(color);
            targetOrbitPoint.set(pos.x, pos.y, pos.z);
            targetCameraDistance = 0.2;
            isAnimatingOrbitPoint = true;
            isAnimatingDistance = true;
            
            // reset previous selection
            if (selectedColorIndex >= 0 && instancedMesh) {
                const dummy = new THREE.Object3D();
                instancedMesh.getMatrixAt(selectedColorIndex, dummy.matrix);
                dummy.matrix.decompose(dummy.position, dummy.quaternion, dummy.scale);
                // Restore scale based on visibility setting
                const colorData_item = colorData[selectedColorIndex];
                const targetScale = (hideUnflaggedColors && !colorData_item.flag) ? 0 : 1;
                dummy.scale.set(targetScale, targetScale, targetScale);
                dummy.updateMatrix();
                instancedMesh.setMatrixAt(selectedColorIndex, dummy.matrix);
                instancedMesh.instanceMatrix.needsUpdate = true;
                
                // Also update picking mesh
                if (pickingMesh) {
                    pickingMesh.setMatrixAt(selectedColorIndex, dummy.matrix);
                    pickingMesh.instanceMatrix.needsUpdate = true;
                }
            }

            // highlight the new selection
            selectedColor = color;
            selectedColorIndex = instanceId;

            if (instancedMesh && instanceId >= 0) {
                const dummy = new THREE.Object3D();
                instancedMesh.getMatrixAt(instanceId, dummy.matrix);
                dummy.matrix.decompose(dummy.position, dummy.quaternion, dummy.scale);
                
                // FIX: If previously hidden (scale ~0), quaternion might be invalid.
                // Reset to safe defaults.
                if (dummy.scale.x < 0.001) {
                    dummy.quaternion.identity();
                    dummy.position.set(pos.x, pos.y, pos.z);
                }
                
                dummy.scale.set(2.4, 2.4, 2.4);
                dummy.updateMatrix();
                instancedMesh.setMatrixAt(instanceId, dummy.matrix);
                instancedMesh.instanceMatrix.needsUpdate = true;
                
                // Also update picking mesh
                if (pickingMesh) {
                    pickingMesh.setMatrixAt(instanceId, dummy.matrix);
                    pickingMesh.instanceMatrix.needsUpdate = true;
                }
            }

            console.log(`Selected: ${color.name} (${color.hex})`);
        }

        // smoothly moves the camera
        // separated target variables for orbit point and distance so that
        // the distance animation can be cancelled if we get a mouse wheel event
        function animate() {
            requestAnimationFrame(animate);

            if (isAnimatingOrbitPoint) {
                orbitPoint.lerp(targetOrbitPoint, 0.1);
                if (orbitPoint.distanceTo(targetOrbitPoint) < 0.001) {
                    isAnimatingOrbitPoint = false;
                }
            }

            if (isAnimatingDistance) {
                cameraDistance += (targetCameraDistance - cameraDistance) * 0.1;
                if (Math.abs(targetCameraDistance - cameraDistance) < 0.001) {
                    isAnimatingDistance = false;
                }
            }

            // keyboard movement
            handleKeyboardMovement();

            updateCameraPosition();

            renderer.render(scene, camera);
        }

        // Throttle tooltip updates for performance (GPU picking is fast, but we still throttle to avoid excessive rendering)
        let lastTooltipUpdate = 0;
        const tooltipThrottleMs = 16; // ~60fps updates

        function updateTooltip(event) {
            if (!instancedMesh) return;

            const now = performance.now();
            if (now - lastTooltipUpdate < tooltipThrottleMs) return;
            lastTooltipUpdate = now;

            const tooltip = document.getElementById('tooltip');
            const tooltipName = tooltip.querySelector('.tooltip-name');
            const tooltipHex = tooltip.querySelector('.tooltip-hex');

            const instanceId = pickColorAtPixel(event.clientX, event.clientY);

            if (instanceId >= 0) {
                const color = colorData[instanceId];

                tooltipName.textContent = color.name;
                tooltipHex.textContent = color.hex;

                tooltip.style.display = 'block';
                tooltip.style.left = (event.clientX + 15) + 'px';
                tooltip.style.top = (event.clientY + 15) + 'px';
            } else {
                tooltip.style.display = 'none';
            }
        }

        function handleKeyboardMovement() {
            const moveSpeed = 0.01;

            if (keys['w'] || keys['W']) orbitPoint.z -= moveSpeed;
            if (keys['s'] || keys['S']) orbitPoint.z += moveSpeed;
            if (keys['a'] || keys['A']) orbitPoint.x -= moveSpeed;
            if (keys['d'] || keys['D']) orbitPoint.x += moveSpeed;
            if (keys[' ']) orbitPoint.y += moveSpeed;
            if (keys['Control']) orbitPoint.y -= moveSpeed;
        }

        function setupEventListeners() {
            // Mouse controls
            renderer.domElement.addEventListener('mousedown', onMouseDown);
            renderer.domElement.addEventListener('mousemove', onMouseMove);
            renderer.domElement.addEventListener('mouseup', onMouseUp);
            renderer.domElement.addEventListener('wheel', onMouseWheel);
            renderer.domElement.addEventListener('contextmenu', (e) => e.preventDefault());

            // Keyboard controls
            window.addEventListener('keydown', (e) => {
                keys[e.key] = true;
            });
            window.addEventListener('keyup', (e) => {
                keys[e.key] = false;
            });

            // Window resize
            window.addEventListener('resize', onWindowResize);

            // Search
            const searchInput = document.getElementById('search-input');
            const searchResults = document.getElementById('search-results');
            let currentSelectedIndex = -1;
            let currentMatches = [];

            // Debounce function
            function debounce(func, wait) {
                let timeout;
                return function executedFunction(...args) {
                    const later = () => {
                        clearTimeout(timeout);
                        func(...args);
                    };
                    clearTimeout(timeout);
                    timeout = setTimeout(later, wait);
                };
            }

            // Update search results
            const updateSearchResults = (query) => {
                if (query.length < 2) {
                    searchResults.style.display = 'none';
                    currentMatches = [];
                    currentSelectedIndex = -1;
                    return;
                }

                currentMatches = colorData.filter(color =>
                    color.name.toLowerCase().includes(query) ||
                    color.hex.toLowerCase().includes(query)
                );

                if (currentMatches.length > 0) {
                    searchResults.innerHTML = currentMatches.map((color, index) => `
                        <div class="search-result-item ${index === 0 ? 'selected' : ''}" data-name="${color.name}" data-index="${index}">
                            <div class="color-swatch" style="background-color: ${color.hex}"></div>
                            <div class="color-info">
                                <div class="color-name">${color.name}</div>
                                <div class="color-hex">${color.hex}</div>
                            </div>
                        </div>
                    `).join('');
                    searchResults.style.display = 'block';
                    currentSelectedIndex = 0;

                    // Automatically jump to the top result
                    const topColor = currentMatches[0];
                    const colorIndex = colorData.findIndex(c => c.name === topColor.name);
                    if (colorIndex >= 0) {
                        jumpToColor(colorData[colorIndex], colorIndex);
                    }

                    // Add click handlers
                    searchResults.querySelectorAll('.search-result-item').forEach(item => {
                        item.addEventListener('click', () => {
                            const colorName = item.getAttribute('data-name');
                            const colorIndex = colorData.findIndex(c => c.name === colorName);
                            if (colorIndex >= 0) {
                                jumpToColor(colorData[colorIndex], colorIndex);
                                searchInput.value = '';
                                searchResults.style.display = 'none';
                                currentMatches = [];
                                currentSelectedIndex = -1;
                            }
                        });
                    });
                } else {
                    searchResults.style.display = 'none';
                    currentMatches = [];
                    currentSelectedIndex = -1;
                }
            };

            // Debounced search function
            const debouncedSearch = debounce(updateSearchResults, 150);

            searchInput.addEventListener('input', (e) => {
                const query = e.target.value.trim().toLowerCase();
                debouncedSearch(query);
            });

            // Keyboard navigation
            searchInput.addEventListener('keydown', (e) => {
                if (currentMatches.length === 0) return;

                switch (e.key) {
                    case 'ArrowDown':
                        e.preventDefault();
                        currentSelectedIndex = Math.min(currentSelectedIndex + 1, currentMatches.length - 1);
                        updateSelectedItem();
                        scrollToSelectedItem();
                        // jump to the newly selected color
                        if (currentSelectedIndex >= 0 && currentSelectedIndex < currentMatches.length) {
                            const selectedColor = currentMatches[currentSelectedIndex];
                            const colorIndex = colorData.findIndex(c => c.name === selectedColor.name);
                            if (colorIndex >= 0) {
                                jumpToColor(colorData[colorIndex], colorIndex);
                            }
                        }
                        break;
                    case 'ArrowUp':
                        e.preventDefault();
                        currentSelectedIndex = Math.max(currentSelectedIndex - 1, 0);
                        updateSelectedItem();
                        scrollToSelectedItem();
                        // Jump to the newly selected color
                        if (currentSelectedIndex >= 0 && currentSelectedIndex < currentMatches.length) {
                            const selectedColor = currentMatches[currentSelectedIndex];
                            const colorIndex = colorData.findIndex(c => c.name === selectedColor.name);
                            if (colorIndex >= 0) {
                                jumpToColor(colorData[colorIndex], colorIndex);
                            }
                        }
                        break;
                    case 'Enter':
                        e.preventDefault();
                        if (currentSelectedIndex >= 0 && currentSelectedIndex < currentMatches.length) {
                            const selectedColor = currentMatches[currentSelectedIndex];
                            const colorIndex = colorData.findIndex(c => c.name === selectedColor.name);
                            if (colorIndex >= 0) {
                                jumpToColor(colorData[colorIndex], colorIndex);
                                searchInput.value = '';
                                searchResults.style.display = 'none';
                                currentMatches = [];
                                currentSelectedIndex = -1;
                            }
                        }
                        break;
                    case 'Escape':
                        searchResults.style.display = 'none';
                        currentMatches = [];
                        currentSelectedIndex = -1;
                        break;
                }
            });

            function updateSelectedItem() {
                const items = searchResults.querySelectorAll('.search-result-item');
                items.forEach((item, index) => {
                    if (index === currentSelectedIndex) {
                        item.classList.add('selected');
                    } else {
                        item.classList.remove('selected');
                    }
                });
            }

            function scrollToSelectedItem() {
                const selectedItem = searchResults.querySelector('.search-result-item.selected');
                if (selectedItem) {
                    selectedItem.scrollIntoView({
                        behavior: 'smooth',
                        block: 'nearest'
                    });
                }
            }

            searchInput.addEventListener('blur', () => {
                setTimeout(() => {
                    searchResults.style.display = 'none';
                }, 200);
            });

            // Color space selector
            const colorSpaceSelector = document.getElementById('color-space-selector');
            colorSpaceSelector.addEventListener('change', async (e) => {
                const selectedSpace = e.target.value;
                if (colorSpaces[selectedSpace]) {
                    currentColorSpace = colorSpaces[selectedSpace];
                    document.getElementById('loading').style.display = 'block';
                    updateLoadingProgress(0, `Switching to ${currentColorSpace.name}...`);
                    await updateSpherePositions();
                    updateLoadingProgress(100, 'Complete!');
                    setTimeout(() => {
                        document.getElementById('loading').style.display = 'none';
                    }, 500);
                }
            });

            // Settings menu
            const settingsMenu = document.getElementById('settings-menu');
            const settingsToggle = document.getElementById('settings-toggle');
            
            settingsToggle.addEventListener('click', (e) => {
                e.stopPropagation();
                settingsMenu.classList.toggle('open');
            });

            // Close menu when clicking outside
            document.addEventListener('mousedown', (e) => {
                if (!settingsMenu.contains(e.target)) {
                    settingsMenu.classList.remove('open');
                }
            });

            // Close menu on Escape key
            window.addEventListener('keydown', (e) => {
                if (e.key === 'Escape') {
                    settingsMenu.classList.remove('open');
                }
            });

            // Scale slider
            const scaleSlider = document.getElementById('scale-slider');
            const scaleValue = document.getElementById('scale-value');
            
            // Initialize scale from slider and display
            scale = parseFloat(scaleSlider.value);
            scaleValue.textContent = scale.toFixed(2);

            scaleSlider.addEventListener('input', async () => {
                scale = parseFloat(scaleSlider.value);
                scaleValue.textContent = scale.toFixed(2);

                // Update sphere positions with new scale
                if (instancedMesh && currentColorSpace) {
                    await updateSpherePositions();
                }
            });

            // Background color sliders
            const backgroundRedSlider = document.getElementById('background-red');
            const backgroundGreenSlider = document.getElementById('background-green');
            const backgroundBlueSlider = document.getElementById('background-blue');
            const backgroundRedValue = document.getElementById('background-red-value');
            const backgroundGreenValue = document.getElementById('background-green-value');
            const backgroundBlueValue = document.getElementById('background-blue-value');

            // Initialize background values from sliders and display
            backgroundRed = parseInt(backgroundRedSlider.value);
            backgroundGreen = parseInt(backgroundGreenSlider.value);
            backgroundBlue = parseInt(backgroundBlueSlider.value);
            backgroundRedValue.textContent = backgroundRed;
            backgroundGreenValue.textContent = backgroundGreen;
            backgroundBlueValue.textContent = backgroundBlue;

            // Update scene background
            updateSceneBackground();

            backgroundRedSlider.addEventListener('input', () => {
                backgroundRed = parseInt(backgroundRedSlider.value);
                backgroundRedValue.textContent = backgroundRed;
                updateSceneBackground();
            });

            backgroundGreenSlider.addEventListener('input', () => {
                backgroundGreen = parseInt(backgroundGreenSlider.value);
                backgroundGreenValue.textContent = backgroundGreen;
                updateSceneBackground();
            });

            backgroundBlueSlider.addEventListener('input', () => {
                backgroundBlue = parseInt(backgroundBlueSlider.value);
                backgroundBlueValue.textContent = backgroundBlue;
                updateSceneBackground();
            });

            // Hide unflagged colors checkbox
            const hideUnflaggedCheckbox = document.getElementById('hide-unflagged-checkbox');
            hideUnflaggedCheckbox.checked = hideUnflaggedColors;
            
            hideUnflaggedCheckbox.addEventListener('change', (e) => {
                hideUnflaggedColors = e.target.checked;
                updateUnflaggedVisibility();
            });
        }

        // events

        function onMouseDown(event) {
            if (event.button === 2) { // Right click
                isDragging = true;
                previousMousePosition = { x: event.clientX, y: event.clientY };
            } else if (event.button === 0) { // Left click
                handleColorClick(event);
            }
        }

        function onMouseMove(event) {
            if (isDragging) {
                const deltaX = event.clientX - previousMousePosition.x;
                const deltaY = event.clientY - previousMousePosition.y;

                cameraAngles.theta += deltaX * 0.005;
                cameraAngles.phi += deltaY * 0.005;

                // Clamp phi to prevent gimbal lock
                cameraAngles.phi = Math.max(0.1, Math.min(Math.PI - 0.1, cameraAngles.phi));

                previousMousePosition = { x: event.clientX, y: event.clientY };
            } else {
                // Handle tooltip on hover
                updateTooltip(event);
            }
        }

        function onMouseUp(event) {
            if (event.button === 2) {
                isDragging = false;
            }
        }

        function onMouseWheel(event) {
            event.preventDefault();
            
            if (isAnimatingDistance) {
                isAnimatingDistance = false;
            }
            
            const delta = event.deltaY * 0.001;
            cameraDistance = Math.max(0.1, Math.min(10, cameraDistance + delta));
        }

        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        }

        init();
        loadColors();
        animate();
    </script>
</body>
</html>
